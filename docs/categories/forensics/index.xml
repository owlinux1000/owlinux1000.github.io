<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>forensics on $ make life</title>
    <link>https://owlinux1000.github.io/categories/forensics/</link>
    <description>Recent content in forensics on $ make life</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 29 Apr 2019 07:03:53 +0900</lastBuildDate>
    
	<atom:link href="https://owlinux1000.github.io/categories/forensics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>平成のうちに理解しておくYara 入門</title>
      <link>https://owlinux1000.github.io/blog/yara/</link>
      <pubDate>Mon, 29 Apr 2019 07:03:53 +0900</pubDate>
      
      <guid>https://owlinux1000.github.io/blog/yara/</guid>
      <description>&amp;ldquo;平成も終わるし、知ったかぶりしてる技術を令和に持ち越さないようにしような&amp;rdquo;
 目次  Yara とは はじめてのYara ルール 文字列を用いたYara ルール 正規表現を用いたYara ルール 複数条件を用いたYara ルール Yara の便利機能 モジュール機能を用いたYara ルール Pythonから利用するYara ルール まとめ  Yara とは Yaraは、「Yara ルール」と呼ばれる専用のルールを用いて、マルウェアや悪意あるファイルなどを検知することのできるツールです。Yara ルールでは、文字列による検査や正規表現、論理条件などをサポートしており複雑なルールを構築することもできます。利用例として、あるマルウェアファミリーの特徴をYara ルールとして作成しておくことで、新しいマルウェアが発見されたときに既知のマルウェアファミリーに性質が近いかどうかなどを検知することができます。Yara は、Cuckoo Sandboxなど他のセキュリテイツールと連携していることが多く、セキュリテイに関わる人間としては、一度読み書きしておいた方が良いツールの１つです。本記事では、Yara を使ったこと無い人向けに基本的な概念やルールを幅広くご紹介します。
まずは、Yara を利用するためにインストールしましょう。Ubuntu では、aptからインストールすることができます。
$ sudo apt install yara また、Macではbrewからインストールすることが可能です。
$ brew install yara インストールできたら、以下のコマンドを入力して、Yara のバージョンを確認してください。なお本記事では、バージョン3.9.0を対象に執筆しています。
$ yara --version 3.9.0 はじめてのYara ルール では、さっそくはじめてのYara ルールを作成してみましょう。以下に、必ず検知するルールを示します。
// hello_rule.yara rule hello { condition: true } Yaraでは、ruleキーワードを用いてルールを作成します。ここでhelloはルール名にあたり、実際の条件がconditionがtrueのときに検知することを意味しています。本例では、一般的なプログラミング言語と同様に、条件文が必ず真となります。そのため、必ず検知することができます。また、先頭の1行目は、コメント文です。Yara ルールのファイルの拡張子は、.yaraや.yarの場合が多いです。
では、このルールを用いて実際に検知するか確認してみましょう。そのために検査対象となるファイルをhello.txtとして以下の内容で作成してください。
HelloWorld! 以下の以下コマンドを実行してください。
$ yara hello_rule.</description>
    </item>
    
    <item>
      <title>binarycookiesファイル解析ツールbincookie</title>
      <link>https://owlinux1000.github.io/blog/analyzing_binary_cookie/</link>
      <pubDate>Wed, 06 Mar 2019 23:10:49 +0900</pubDate>
      
      <guid>https://owlinux1000.github.io/blog/analyzing_binary_cookie/</guid>
      <description>はじめに iOSやMacのフォレンジックでは、アーティファクトの1つとしてCookie情報を利用します。macOSでは、/User/ユーザ名/Library/Cookies/Cookies.binarycookies に存在します。しかしながら、本ファイルは拡張子からもわかるようにバイナリ形式になっています。そこで、本記事ではこのバイナリファイルを解析するツールをご紹介します。
bincookie bincookie
拙作のGolangで実装された解析ツールです。goユーザならgo getで入りますし、Releaseからバイナリのダウンロードもできます。
本ツールの特徴として、curlコマンドで利用できる形式として出力する点です。私の手元にあった/Users/ユーザ名/Library/Cookies/com.apple.iTunes.binarycookiesに対して適用した例が以下です。
$ bincookie /Users/ユーザ名/Library/Cookies/com.apple.iTunes.binarycookies # Netscape HTTP Cookie File # This file was generated by owlinux1000&#39;s bincookie # https://github.com/owlinux1000/bincookie .apple.com	TRUE	/	TRUE	1566914111	xp_ci	hogehogehoge .apple.com	TRUE	/	TRUE	1566914111	xp_ab	hogehogehoge .xp.apple.com	TRUE	/	TRUE	1566914111	xp_aci	hogehogehog また、同様のソフトウェアとして以下の2つが存在します。
 BinaryCookieReader Burnt Cookie  おわりに binarycookiesファイル解析ツールbincookieの宣伝をしました。binarycookiesファイルを解析する際には、ぜひbincookie使ってみてください。バグか何かあったらissueやPR待ってます。</description>
    </item>
    
    <item>
      <title>iOSデバイスフォレンジック入門</title>
      <link>https://owlinux1000.github.io/blog/an_introduction_of_ios_forensics/</link>
      <pubDate>Thu, 28 Feb 2019 21:00:00 +0900</pubDate>
      
      <guid>https://owlinux1000.github.io/blog/an_introduction_of_ios_forensics/</guid>
      <description>はじめに 本記事では、iOSフォレンジックをやったことない人向けに基本的な情報をまとめてみました。取っ掛かりとしては簡単に読める内容だと思います。主にiOSデバイスのバックアップデータやその解析ツールについてご紹介しています。
準備 本記事では主に以下のデバイスやソフトウェアを使って検証しています。当該デバイスやバージョンでない場合同じ結果や解釈にならない可能性もありますのでご了承ください。
 iPad mini4 (iOS 12.1.1 非Jailbreak) MacBookPro (High Sierra 10.13.6) iTunes (12.8.3)  iOS 概要 iOSは、iPhoneやiPad、Apple Watch等で利用されているOSです。iOSは大きく分けて、以下の4つのシステムから構成されています。
 Cocoa Touch Media Cocoa Service Core OS  Cocoa Touchは、名前からもわかるようにタッチ操作を始めとするユーザーインタフェースのシステムです。Mediaは、動画像や音楽などMedia用のシステムです。Cocoa Serviceは、アプリケーションにとって必要な基本的なシステムを提供しています。最後のCore OSは、ハードウェアに近いより低レイヤーなネットワークやメモリ管理、スレッドの機能などを提供しています。
次に、iOSで用いられているファイルシステムについて簡単にご紹介いたします。近年のiOSではAPFS（Apple File System）と呼ばれるファイルシステムが利用されています。従来はHFS、HFS+が使われていましたが、2017年のiOS 10.3からAPFSが導入されました。APFSの特徴としては、inodeが64bitに拡張されたためより多くのファイルが扱えるようになったり、CoW（Copy on Write）のサポート、タイムスタンプがナノ秒単位まで記録するようになったりなど従来のファイルシステムに比べ大きく変わっています。より詳細な情報としては以下のWebページなどが参考になると思います。
 Apple File System ファイルシステムがAPFSになった事による変更点  iTunesバックアップ iOSデバイスにおけるデータを抽出する方法としては、物理と論理の2通りの方法があります。しかしながら、物理デバイスから情報を抽出するためには、機材が必要であったり、論理面でも有償のツールが必要なことが多く入門には不向きです。そこで本記事では、iTunesのバックアップデータを元にiOSデバイスのフォレンジック調査に役立つ情報をまとめていこうと思います。もしすでにホストマシンにiTunesを用いてバックアップをとっている人はそのデータをお使いできます。もしなければ、iOSデバイスを接続し、iTunesの画面よりバックアップをとってください。
iOSデバイスのバックアップデータは、以下の場所に格納されます。
 Mac：/User/ユーザ名/Library/Application Support/MobileSync/Backup Windows：\AppData\Roaming\Apple Computer\MobileSync\Backup\ Windowsストアアプリ経由でiTunesを入れた場合：%USERPROFILE%\Apple\MobileSync\Backup  バックアップを行っている状態で、上記フォルダにアクセスするとハッシュ値が名前のフォルダがあると思います。それがバックアップデータの本体です。バックアップデータのフォルダの中には、主に以下のファイルやフォルダが格納されていると思います。
 Manifest.plist Manifest.db Info.plist Status.plist 大量のフォルダ  Manifest.plistは、主にバックアップの内容について記載されています。例えばバックアップした日時、バックアップを暗号化しているかどうか、インストールしたアプリケーション一覧などがあげられます。Manifest.dbは、SQLiteのデータベースファイルで、バックアップデータに含まれるファイルやフォルダの情報が格納してあります。fileIDカラムには、SHA1が格納されており、これはファイル名を表しています。そのため、バックアップフォルダの中で、このハッシュ値を使って検索したりします。
以下の図は、DB Browser for SQLiteでManifest.dbを読み込んだときの図です。CUIのsqlite3コマンドなどでも良いのですが、フォレンジック業務をやるときには、フィルターやソート、検索などが手軽に使えるほうが効率が良いので、こういったGUIツールを使っています。
Info.plistは、主にバックアップ対象のデバイス情報について記載されています。例えば、IMEIやシリアルナンバー、最後にバックアップした日などが挙げられます。Status.plistは、主にバックアップ状況について記載されています。</description>
    </item>
    
    <item>
      <title>フォレンジックのためのシステム時刻入門</title>
      <link>https://owlinux1000.github.io/blog/system_time_for_forensics/</link>
      <pubDate>Sat, 23 Feb 2019 20:37:24 +0900</pubDate>
      
      <guid>https://owlinux1000.github.io/blog/system_time_for_forensics/</guid>
      <description>はじめに フォレンジックなどをやっていると様々な時刻形式と直面することがあります。いざ調べてみると時刻形式は、プラットフォームによって異なる場合が多いことに気づきました。時刻の情報はタイムライン作成では、とても重要な要因となってくるので、適切に時刻を解釈することが必要です。本記事では、よく見る3つの時刻表記についてご紹介します。
UNIX time  UNIX timeはDFIRだけに限らず多くの場面でよく見かける時刻形式の1つです。UTC（協定世界時）の1970年1月1日0時0分0秒からの経過秒数で表す時刻形式です。主要なプログラミング言語の代表的な時刻を扱うライブラリなどでは、UNIX timeをサポートしています。例えばRubyでは以下の様に、UNIX timeを扱うことができます。  require &amp;#39;time&amp;#39; JST_OFFSET = 3600 * 9 puts Time.parse(&amp;#34;1970-01-01 00:00:00&amp;#34;).to_i + JST_OFFSET #=&amp;gt; 0 puts Time.at(0) #=&amp;gt; 1970-01-01 09:00:00 +0900 Apple Cocoa Core Data timestamp  Apple Cocoa Core Data timestampは、主にMac OSやiOSで見かける時刻形式です。Cocoaとは、macOS用のフレームワークです。また、Mac absolute timeと表記されることもあります。本時刻形式は、UTCの2001年1月1日0時0分0秒からの経過秒数で表す時刻形式です。UNIX timeとの差分は、978307200なので、これを考慮すればUNIX timeからすぐ算出することができます。  WebKit/Chrome time  WebKit/Chrome timeは、Google Chrome、OperaやSafariなどのデータで使われている時刻形式です。本時刻形式は、UTCの1601年1月1日0時0分0秒からの経過マイクロ秒で表す時刻形式です。UNIX timeなどと異なりマイクロ秒なので値が大きいという特徴があります。  便利なツールやサイト 以下の2つは、システム時刻変換をする際に、使いやすかったツールです。
 Epoch Converter  本記事で説明した時刻形式などは概ねカバーしているツールです   DCode  Epoch Converterと同様の機能を有しているWindowsアプリケーション    参考文献  Practical Mobile Forensics - Third Edition  </description>
    </item>
    
  </channel>
</rss>